# DeepLearnUtils 
# Copyright (c) 2017-8 Eric Kerfoot, KCL, see LICENSE file

'''
This is a Eidolon script used to send the selected image object to a running instance of the SegServ server and then
load the returned segmentation image. This assumes the segmentation model accepts single channel images and returns
a binary segmentation, for anything more complex the requestSeg() function should be changed.
'''
from __future__ import division, print_function
from eidolon import ImageSceneObject,processImageNp, trange, first, rescaleArray, printFlush
import io, sys, urllib2

import numpy as np

try:
    from imageio import imwrite, imread
except:
    from scipy.misc import imsave as imwrite,imread
    
sys.path.append(scriptdir)
import segmenter

meta='/home/localek10/data/Projs/BramRealTime/sharpen-20180213001341/model.ckpt-10001.meta'

if 'sharpen' not in locals():
    sharpen=segmenter.Segmenter(meta)


mgr=mgr # pylint:disable=invalid-name,used-before-assignment

# the server url, defaulting to my desktop if "--var url,<URL-to-server>" is not present on the command line
localurl=locals().get('url','http://bioeng187-pc:5000/segment/sharpen')


def requestSeg(inmat,outmat,url,patchsize=(64,64)):
    task=mgr.getCurrentTask()
    task.setMaxProgress(m.shape[2]*m.shape[3])
    task.setLabel('Segmenting...')
    count=0
    w,h=patchsize
    inmat=rescaleArray(inmat)
    
    for s,t in trange(inmat.shape[2],inmat.shape[3]):
        count+=1
        task.setProgress(count)
            
        img=inmat[:,:,s,t]
        
        if img.max()>img.min(): # non-empty image
            iw,ih=img.shape
            numw=iw//w+(1 if iw%w!=0 else 0)
            numh=ih//h+(1 if ih%h!=0 else 0)
            
            for x,y in trange(numw,numh):
                inimg=img[x*w:(x+1)*w,y*h:(y+1)*h]
                sharpen.tempimg[0,...,0]=inimg
                pred=sharpen.sess.run(sharpen.ypred,feed_dict=sharpen.feeddict)
                outimg=np.squeeze(pred[0])
                
                
                #outimg=sharpen.apply(inimg,False,False)
                outmat[x*w:(x+1)*w,y*h:(y+1)*h,s,t]=rescaleArray(outimg,inimg.min(),inimg.max())
                
                printFlush(inimg.min(),inimg.max(),outimg.min(),outimg.max())
 
            

o=mgr.win.getSelectedObject() or first(mgr.objs)

if o is None:
    mgr.showMsg('Load and select an image object before executing this script')
elif not isinstance(o,ImageSceneObject):
    mgr.showMsg('Selected object %r is not an image'%o.getName())
else:
    oo=o.plugin.clone(o,o.getName()+'_sharp')
    
    with processImageNp(oo,True) as m:
        requestSeg(m,m,localurl)
                    
    mgr.addSceneObject(oo)
    